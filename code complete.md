# 一、欢迎进入软件构建的世界
* 软件构建是软件开发的核心活动
* 软件构建的主要活动包括：详细设计、编码、调试、集成、开发者测试（单元测试和集成测试）

# 用隐喻来更充分地理解软件开发
* 隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好地理解；
软件的构建过程---->房屋的建设过程发现：准备的必要性以及大型小型项目之间的差异
软件开发中的实践--->智慧工具箱中的工具:因地制宜地选择正确工具是成为能有效编程的程序员的关键；

# 三思而后行：前期准备
### 构建之前要做准备的论据
+诉诸逻辑：管理者----确定时间、人数以及计算机台数；技术角度：清楚要建造的是什么。总不希望花费很多时间和金钱，却毫无必要地走进死胡同
+诉诸类比：做软件时，必须按照正确的顺序去做事情，程序员是软件食物链最后一环。架构师吃需求，设计师吃架构，程序员消化设计；
+诉诸数据：在一开始把事情做对是最合算的，进行非必要的改动的代价是高昂的
### 架构的典型组成部分
+ Program Organization (程序组织)
+ Major Classes（主要的类）:80/20法则：对那些构成系统80%行为的20%的类进行详细说明
+ Data Design（数据设计）
+ Business Rules（业务规则）
+	User Interface Design（用户界面设计）：在需求阶段/软件架构中进行详细说明
+	Resource Management(资源管理)
+	Security(安全性)
+	Performance(性能)
+	Scalability（可伸缩性）：系统增长以满足未来需求的能力
+	Interoperablility（互用性）
+	Internationalization/Localization（国际化/本地化）
+	Input/Output（输入/输出）：详细定义读取策略：先做，后做还是即时做
+	Error Processing（错误处理）
+	Fault Tolerance(容错性)
+	Architectural Feasibility（架构的可行性）
+	Overengineering（过度工程）
+	Buy-vs-Build Decisions（关于买还是造的决策 ）
+	Reuse Decisions（关于复用的决策）
+	Change Strategy （变更策略）
+	General Architectural Quality（架构的总体质量）
### 花费在前期准备上的时间长度
问题定义、需求分析、软件架构上花费的时间依据项目的需要而变化，一个运作良好的项目在需求、架构以及其他前期计划方面投入10%~20%的工作量和20%~30%的时间

# 关键的“构建”决策
+ 思考的能力取决于你是否知道能够表达该思想的词汇；
+ 编程约定：开始“构建”前，明确编程约定：要达到的细节精确度：在编写完软件之后，几乎不可能改变（翻新）软件所遵循的编码约定；
+ 技术浪潮中的位置:技术周期（浪潮）意味着不同的变成实践，编程实践取决于你在技术浪潮中所处的位置；
+ 编程工具不应该决定你的编程思路，大多数重要的编程原则并不依赖特定的语言，而依赖于你使用语言的方式：“programming in a language”:将他们的思想限制于“语言直接支持的那些构件”，如果语言工具是初级的，那么程序员的思想也是初级的；“programming into a language” 首先决定他要表达的思想是什么，然后决定如何使用特点语言提供的工具来表达这些思想；

# 软件构建中的设计
### 软件中的挑战
+ 设计是一个险恶的问题；
+ 设计是个了无章法的过程（即使它能得到清爽的成果）：软件设计的成果应该是组织良好，干净利落；设计永无止境，通常到你没时间再做了为止
+ 设计就是确定取舍和调整顺序的过程
+ 设计收到诸多限制；
+ 设计是不确定的；
+ 设计是自然而然形成的；
### 关键的设计概念
##### 软件的首要技术使命：管理复杂度
+ 偶然的难题和本质的难题---难题的根源在于复杂性；
+ 管理复杂度的重要性：项目失败除了差强人意的需求/规划/管理，如果是技术因素，那就是失控的复杂度了；把复杂问题分解成简单的部分；
+ 应对复杂度：高代价低效率的设计源于：复杂方法解决简单问题；简单却错误方法解决复杂问题；不恰当的复杂方法解决复杂问题；管理复杂度：同一时间需要处理的本质复杂度的量减到最少；不让偶然性的复杂度无谓地快速增长；

##### 理想设计特性

+ 最小的复杂度；
+ 易于维护（self-explanatory）
+ 松散耦合：通过应用类接口中的合理抽象、封装性及信息隐藏等原则，设计处相互关联尽可能最小的类。
+ 可扩展性
+ 可重用性：
+ 高扇入（high fan-in）:大量的类使用某个给定的类，设计出的系统很好地利用了在较低层测上的工具类；
+ 低扇出（low fan-out）让一个类里少量或适中的使用其他类。低扇出是有益的
+ 可移植性：
+ 精简性：
+ 层次性：把低劣代码的烂泥潭紧闭起来；如果最终抛弃/重构旧代码，不必修改除交互层之外的任何新代码；
+ 标准技术：使用标准化，常用的方法，让系统给人一种熟悉的感觉；

##### 设计层次
缺图1
1.软件系统
2.分解子系统/包时特别重要的是：不同子系统之间相互通信的规则，简化子系统间的交互关系，设计图应该是无环图；
3.分解为类：定义类接口
4.分解成子程序：细化出类的私有子程序；完整的定义出类内部的子程序，有助于更好的理解类的接口，反过来，又有助于对类的接口进行进一步修改。
5.子程序内容的设计：编写伪代码、选择算法、组织子程序内部的代码块、编写代码

##### 设计构造块：启发式方法
1.找出现实世界中的对象，使用对象进行设计的步骤是：
    1.	辨识对象及其属性（method，data）：
    2.	确定可以对各个对象进行的操作
    3.	确定各个对象能对其他对象进行的操作：对象间常见的关系：包含和继承
    4.	确定对象的哪些部分对其他对象可见--public/private
    5.	定义每个对象的接口：对象对其他对象暴露的数据及方法都被称为该对象的“public interface”，对象通过继承关系向其派生对象暴露的部分则称    为“protected interface”
2.抽象
3.封装
4.继承
5.信息隐藏：
秘密是:隐藏复杂度，隐藏变化源；
障碍是:1.信息过度分散 2.循环依赖 3.把类内数据误认为全局数据 4.可以察觉的性能损耗
价值是：独特的启发力，激发出有效的设计方案； 有助于设计类的公开接口（这个类需要隐藏什么？接口设计的核心）“我该隐藏些什么？”
6找出容易改变的区域
7.松散耦合：（类和子程序是用来降低复杂度的首选和最重要的智力工具）
耦合标准：规模，可见性，灵活性
耦合的种类：简单数据参数耦合、简单对象耦合、对象参数耦合、语义上的耦合（非常危险，经常性会遇到！！）
8.查阅常用的设计模式：
9.其他的启发式方法：
高内聚性、构造分层结构、严格描述类契约、分配职责、为测试而设计、避免失误、有意识地选择绑定时间、创建中央控制点、考虑使用蛮力破坏、保持设计的模块化、



